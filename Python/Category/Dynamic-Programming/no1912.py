# 문제 
'''
n 개의 정수로 이루어진 임의의 수열이 주어진다.
우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.
단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10,-4,3,1,5,6,-35,12,21,-1 이라는 수열이 주어졌다고 하자.
여기서 정답은 12+21인 33이 정답이 된다. 
'''

# 입력
'''
첫째 줄에 정수 n(1 <= n <= 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다.
수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.
'''

# 출력
'''
첫째 줄에 답을 출력한다.
'''
# 첫 시도 이웃한 양수들끼리의 합의 최댓값 구하기(특정 상황에서 최댓값이 나오지 않음)
# n = int(input("n: "))
# num_list = [int(x) for x in input().split()]
# target = [1 if x > 0 else 0 for x in num_list]

# sum_list = []

# temp_sum = 0

# if 1 in target:
#     for x, y in zip(num_list, target):
#         if y == 0:
#             sum_list.append(temp_sum)
#             temp_sum = 0
#         else:
#             temp_sum += x
#     sum_list.append(temp_sum)
# else:
#     sum_list = num_list

# print("===== 결과 출력 =====")
# print(max(sum_list))
###############################################################################

n = int(input("n: "))
num_list = [int(x) for x in input().split()]

current_sum = num_list[0]
max_sum = num_list[0]

for i in range(1,n):
    current_sum = max(num_list[i], current_sum + num_list[i])
    max_sum = max(max_sum, current_sum)

print("===== 결과 출력 =====")
print(max_sum)

# 카데인 알고리즘 (Kadane's Algorithm)

'''
정의

- 카데인 알고리즘은 연속된 배열(subarray)의 최대 합을 효율적으로 찾는 알고리즘이다.
- 동적 프로그래밍(DP) 기법을 활용하여, 현재까지의 최대 부분 합을 갱신하면서 전체 배열을 한 번만 순회하여 답을 구한다.

장점

1. 시간 복잡도가 O(N)
    : 전체 배열을 한 번만 순회하므로, 브루트 포스(완전 탐색) 방식의 O(N^2)보다 훨씬 빠르다.
2. 공간 복잡도가 O(1)
    : 추가적인 배열을 사용하지 않고, 몇 개의 변수만 유지하면 되므로 메모리 사용이 적다.
3. 단순한 구현
    : 직관적인 방식으로 구현할 수 있어 이해하기 쉽다.

단점

1. 음수만 있는 배열에서는 문제 발생
    : 배열의 모든 요소가 음수일 경우, 기본적인 카데인 알고리즘은 0을 반환하는데, 실제로는 가장 큰 음수 값이 최대 부분합이어야 한다.
      (이를 해결하려면 별도 처리가 필요함)
2. 부분 배열의 인덱스를 찾기 어려움
    : 최대 부분합은 쉽게 구할 수 있지만, 해당 부분 배열의 시작과 끝 인덱스를 저장하려면 추가적인 코드가 필요하다.
3. 2차원 이상의 배열에는 기본적으로 적용 불가
    : 2D 또는 3D 배열에서는 직접 사용할 수 없으며, 변형된 알고리즘이 필요하다.

정리

- 카데인 알고리즘은 대표적인 최적화된 부분 합 알고리즘으로, 다양한 문제에 활용되지만 한계점도 존재하므로 상황에 맞는 변형이 필요할 수 있다.
'''