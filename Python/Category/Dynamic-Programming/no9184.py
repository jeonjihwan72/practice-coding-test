# 문제 
'''
재귀 호출만 생각하면 신이 난다! 아닌가요?

다음과 같은 재귀함수 w(a, b, c)가 있다.

위의 함수를 구현하는 것은 매우 쉽다.
하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다.
(예를 들면, a=15, b=15, c=15)

a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.

원본 링크 : https://www.acmicpc.net/problem/9184
'''

# 입력
'''
입력은 세 정수 a,b,c로 이루어져 있으며, 한 줄에 하나씩 주어진다.
입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.
'''

# 출력
'''
입력으로 주어진 각각의 a,b,c에 대해서 w(a,b,c)를 출력한다.
'''

# lru_cache를 통해서 메모이제이션을 적용하여 함수의 계산 결과를 캐시하고 재계산을 방지한다.
# None으로 설정하여 캐시 크기에 제한이 없어 필요한 만큼 메모리가 할당된다.
from functools import lru_cache

@lru_cache(None)
def w(a, b, c):
    if a <= 0 or b <= 0 or c <= 0:
        return 1
    if a > 20 or b > 20 or c > 20:
        return w(20,20,20)
    if a < b and b < c:
        return w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)
    return w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1)

while True:
    a, b, c = map(int,input("a, b, c: ").split())
    if a == b == c == -1:
        break
    print(f"w({a}, {b}, {c}) = {w(a,b,c)}")

# 메모이제이션 (Memoization)
'''
메모이 제이션은 함수형 프로그래밍에서 사용하는 최적화 기법이다.
재귀 호출이나 반복 계산을 효율적으로 처리하기 위해 이전에 계산된 값을 저장해두고, 같은 계산을 반복하지 않도록 하는 기법이다.
메모이제이션은 주로 동적 계획법(DP)에서 사용된다.

핵심 방법
. 중복된 계산을 피하기 위해, 계산된 값을 저장해 두고, 같은 입력이 들어오면 저장된 값을 반환한다.
. 즉, 어떤 입력에 대해 계산을 한 번만 수행하고, 그 결과를 재사용하는 방식이다.

작동 원리
1. 처음 계산할 때, 함수를 호출하면 계산이 이루어진다.
2. 계산된 결과는 캐시(메모리) 또는 딕셔너리 같은 자료구조에 저장된다.
3. 동일한 입력값에 대해 함수가 다시 호출되면, 저장된 값을 반환하여 재계산을 방지한다.

장점
1. 성능 향상: 반복 계산을 방지하여 성능을 크게 향상시킨다.
             특히 재귀적인 문제에서 큰 효과를 본다.
2. 메모리 사용: 계산된 값들을 저장하기 때문에 메모리 사용이 늘어나지만,
               불필요한 연산을 줄여 전체 성능이 개선된다.

단점
1. 메모리 사용 증가: 저장할 수 있는 값이 많아지면 메모리 사용량이 증가한다.
                    이는 저장할 수 있는 항목의 수가 많아질수록 더 많은 메모리를 차지하게 된다.
2. 일반적인 캐시 제한 문제: 매우 큰 범위의 값에 대해 계산을 할 때 캐시의 크기 제한이 문제가 될 수 있다.

메모이제이션 vs 동적 계획법

1. 공통점
- 기본적으로 "중복 계산 방지"라는 동일한 목적이 있다.

2. 차이점
- 동적 계획법은 보통 상향식 접근법으로, 작은 문제부터 차례대로 풀어가며 계산한다.
- 메모이제이션은 하향식 접근법으로, 문제를 재귀적으로 풀고 필요할 때마다 계산된 결과를 저장한다.

라이브러리
from functools import lru_cache

함수명 앞에 데코레이션으로 사용
@lru_cache(None) -> 무제한으로 캐시를 할당한다.
'''

#########################################################################################

# # 메모이제이션 방식 함수 구현

# def w(a, b, c):
#     # 최대값을 20으로 설정
#     MAX = 20
    
#     # 3D 배열을 선언하고 초기화
#     dp = [[[None] * (MAX + 1) for _ in range(MAX + 1)] for _ in range(MAX + 1)]
    
#     # 동적 계획법(DP)을 사용하여 계산
#     def dp_w(a, b, c):
#         if a <= 0 or b <= 0 or c <= 0:
#             return 1
#         if a > 20 or b > 20 or c > 20:
#             return dp_w(20, 20, 20)
        
#         if dp[a][b][c] is not None:  # 이미 계산된 값이 있으면 그 값을 리턴
#             return dp[a][b][c]
        
#         if a < b and b < c:
#             dp[a][b][c] = dp_w(a, b, c - 1) + dp_w(a, b - 1, c - 1) - dp_w(a, b - 1, c)
#         else:
#             dp[a][b][c] = dp_w(a - 1, b, c) + dp_w(a - 1, b - 1, c) + dp_w(a - 1, b, c - 1) - dp_w(a - 1, b - 1, c - 1)
        
#         return dp[a][b][c]
    
#     # 최종 결과를 반환
#     return dp_w(a, b, c)

##############################################################################################################

# 타뷸레이션 방식 함수 구현

# def w(a, b, c):
#     MAX = 20
#     # 3D dp 배열 초기화 (0부터 20까지 모든 값을 계산)
#     dp = [[[0] * (MAX + 1) for _ in range(MAX + 1)] for _ in range(MAX + 1)]

#     # 초기 조건: a, b, c가 0 이하일 때는 1
#     for i in range(MAX + 1):
#         for j in range(MAX + 1):
#             for k in range(MAX + 1):
#                 if i <= 0 or j <= 0 or k <= 0:
#                     dp[i][j][k] = 1

#     # 동적 계획법: 작은 값부터 계산
#     for i in range(1, MAX + 1):
#         for j in range(1, MAX + 1):
#             for k in range(1, MAX + 1):
#                 if i > 0 and j > 0 and k > 0:
#                     if i < j and j < k:
#                         dp[i][j][k] = dp[i][j][k-1] + dp[i][j-1][k-1] - dp[i][j-1][k]
#                     else:
#                         dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j-1][k-1]
    
#     # 원하는 값 리턴
#     return dp[min(a, MAX)][min(b, MAX)][min(c, MAX)]

# # 사용 예
# print(w(10, 4, 6))  # 예시 입력
